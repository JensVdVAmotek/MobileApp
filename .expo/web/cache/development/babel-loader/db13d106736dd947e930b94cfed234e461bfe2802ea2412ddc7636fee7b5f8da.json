{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nvar _Reanimated$default$c, _Reanimated$default;\nimport React, { useEffect, useRef } from 'react';\nimport { BaseGesture, CALLBACK_TYPE } from \"./gesture\";\nimport { Reanimated } from \"./reanimatedWrapper\";\nimport { registerHandler, unregisterHandler } from \"../handlersRegistry\";\nimport RNGestureHandlerModule from \"../../RNGestureHandlerModule\";\nimport { baseGestureHandlerWithMonitorProps, filterConfig, findNodeHandle } from \"../gestureHandlerCommon\";\nimport { GestureStateManager } from \"./gestureStateManager\";\nimport { flingGestureHandlerProps } from \"../FlingGestureHandler\";\nimport { forceTouchGestureHandlerProps } from \"../ForceTouchGestureHandler\";\nimport { longPressGestureHandlerProps } from \"../LongPressGestureHandler\";\nimport { panGestureHandlerProps, panGestureHandlerCustomNativeProps } from \"../PanGestureHandler\";\nimport { tapGestureHandlerProps } from \"../TapGestureHandler\";\nimport { State } from \"../../State\";\nimport { EventType } from \"../../EventType\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { onGestureHandlerEvent as _onGestureHandlerEvent } from \"./eventReceiver\";\nvar ALLOWED_PROPS = [].concat(_toConsumableArray(baseGestureHandlerWithMonitorProps), _toConsumableArray(tapGestureHandlerProps), _toConsumableArray(panGestureHandlerProps), _toConsumableArray(panGestureHandlerCustomNativeProps), _toConsumableArray(longPressGestureHandlerProps), _toConsumableArray(forceTouchGestureHandlerProps), _toConsumableArray(flingGestureHandlerProps));\nfunction convertToHandlerTag(ref) {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    var _ref$current$handlerT, _ref$current;\n    return (_ref$current$handlerT = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.handlerTag) !== null && _ref$current$handlerT !== void 0 ? _ref$current$handlerT : -1;\n  }\n}\nfunction extractValidHandlerTags(interactionGroup) {\n  var _interactionGroup$map, _interactionGroup$map2;\n  return (_interactionGroup$map = interactionGroup === null || interactionGroup === void 0 ? void 0 : (_interactionGroup$map2 = interactionGroup.map(convertToHandlerTag)) === null || _interactionGroup$map2 === void 0 ? void 0 : _interactionGroup$map2.filter(function (tag) {\n    return tag > 0;\n  })) !== null && _interactionGroup$map !== void 0 ? _interactionGroup$map : [];\n}\nfunction dropHandlers(preparedGesture) {\n  for (var handler of preparedGesture.config) {\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\n    unregisterHandler(handler.handlerTag);\n  }\n}\nfunction attachHandlers(_ref) {\n  var preparedGesture = _ref.preparedGesture,\n    gestureConfig = _ref.gestureConfig,\n    gesture = _ref.gesture,\n    viewTag = _ref.viewTag,\n    useAnimated = _ref.useAnimated,\n    webEventHandlersRef = _ref.webEventHandlersRef;\n  if (!preparedGesture.firstExecution) {\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n  setImmediate(function () {\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.prepare();\n  });\n  var _loop = function _loop(handler) {\n    RNGestureHandlerModule.createGestureHandler(handler.handlerName, handler.handlerTag, filterConfig(handler.config, ALLOWED_PROPS));\n    registerHandler(handler.handlerTag, handler);\n    setImmediate(function () {\n      var requireToFail = [];\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n      var simultaneousWith = [];\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(handler.config.simultaneousWith);\n      }\n      RNGestureHandlerModule.updateGestureHandler(handler.handlerTag, filterConfig(handler.config, ALLOWED_PROPS, {\n        simultaneousHandlers: simultaneousWith,\n        waitFor: requireToFail\n      }));\n    });\n  };\n  for (var handler of gesture) {\n    _loop(handler);\n  }\n  preparedGesture.config = gesture;\n  for (var _gesture of preparedGesture.config) {\n    if (Platform.OS === 'web') {\n      RNGestureHandlerModule.attachGestureHandler(_gesture.handlerTag, viewTag, !useAnimated, webEventHandlersRef);\n    } else {\n      RNGestureHandlerModule.attachGestureHandler(_gesture.handlerTag, viewTag, !useAnimated);\n    }\n  }\n  if (preparedGesture.animatedHandlers) {\n    preparedGesture.animatedHandlers.value = gesture.map(function (g) {\n      return g.handlers;\n    });\n  }\n}\nfunction updateHandlers(preparedGesture, gestureConfig, gesture) {\n  gestureConfig === null || gestureConfig === void 0 ? void 0 : gestureConfig.prepare();\n  for (var i = 0; i < gesture.length; i++) {\n    var handler = preparedGesture.config[i];\n    if (gesture[i].handlerTag !== handler.handlerTag) {\n      gesture[i].handlerTag = handler.handlerTag;\n      gesture[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n  setImmediate(function () {\n    for (var _i = 0; _i < gesture.length; _i++) {\n      var _handler = preparedGesture.config[_i];\n      _handler.config = gesture[_i].config;\n      _handler.handlers = gesture[_i].handlers;\n      var requireToFail = extractValidHandlerTags(_handler.config.requireToFail);\n      var simultaneousWith = extractValidHandlerTags(_handler.config.simultaneousWith);\n      RNGestureHandlerModule.updateGestureHandler(_handler.handlerTag, filterConfig(_handler.config, ALLOWED_PROPS, {\n        simultaneousHandlers: simultaneousWith,\n        waitFor: requireToFail\n      }));\n      registerHandler(_handler.handlerTag, _handler);\n    }\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = preparedGesture.config.map(function (g) {\n        return g.handlers;\n      });\n    }\n  });\n}\nfunction needsToReattach(preparedGesture, gesture) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n  for (var i = 0; i < gesture.length; i++) {\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction useAnimatedGesture(preparedGesture, needsRebuild) {\n  if (!Reanimated) {\n    return;\n  }\n  function isStateChangeEvent(event) {\n    'worklet';\n    return event.oldState != null;\n  }\n  function isTouchEvent(event) {\n    'worklet';\n\n    return event.eventType != null;\n  }\n  function getHandler(type, gesture) {\n    'worklet';\n\n    switch (type) {\n      case CALLBACK_TYPE.BEGAN:\n        return gesture.onBegin;\n      case CALLBACK_TYPE.START:\n        return gesture.onStart;\n      case CALLBACK_TYPE.UPDATE:\n        return gesture.onUpdate;\n      case CALLBACK_TYPE.CHANGE:\n        return gesture.onChange;\n      case CALLBACK_TYPE.END:\n        return gesture.onEnd;\n      case CALLBACK_TYPE.FINALIZE:\n        return gesture.onFinalize;\n      case CALLBACK_TYPE.TOUCHES_DOWN:\n        return gesture.onTouchesDown;\n      case CALLBACK_TYPE.TOUCHES_MOVE:\n        return gesture.onTouchesMove;\n      case CALLBACK_TYPE.TOUCHES_UP:\n        return gesture.onTouchesUp;\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\n        return gesture.onTouchesCancelled;\n    }\n  }\n  function touchEventTypeToCallbackType(eventType) {\n    'worklet';\n\n    switch (eventType) {\n      case EventType.TOUCHES_DOWN:\n        return CALLBACK_TYPE.TOUCHES_DOWN;\n      case EventType.TOUCHES_MOVE:\n        return CALLBACK_TYPE.TOUCHES_MOVE;\n      case EventType.TOUCHES_UP:\n        return CALLBACK_TYPE.TOUCHES_UP;\n      case EventType.TOUCHES_CANCELLED:\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\n    }\n    return CALLBACK_TYPE.UNDEFINED;\n  }\n  function runWorklet(type, gesture, event) {\n    'worklet';\n\n    var handler = getHandler(type, gesture);\n    if (gesture.isWorklet[type]) {\n      for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        args[_key - 3] = arguments[_key];\n      }\n      handler === null || handler === void 0 ? void 0 : handler.apply(void 0, [event].concat(args));\n    } else if (handler) {\n      console.warn('Animated gesture callback must be a worklet');\n    }\n  }\n  var sharedHandlersCallbacks = Reanimated.useSharedValue(null);\n  var lastUpdateEvent = Reanimated.useSharedValue([]);\n  var stateControllers = [];\n  var callback = function callback(event) {\n    'worklet';\n\n    var currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n    for (var i = 0; i < currentCallback.length; i++) {\n      var gesture = currentCallback[i];\n      if (event.handlerTag === gesture.handlerTag) {\n        if (isStateChangeEvent(event)) {\n          if (event.oldState === State.UNDETERMINED && event.state === State.BEGAN) {\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n          } else if ((event.oldState === State.BEGAN || event.oldState === State.UNDETERMINED) && event.state === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\n          } else if (event.oldState !== event.state && event.state === State.END) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n          } else if ((event.state === State.FAILED || event.state === State.CANCELLED) && event.state !== event.oldState) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n          }\n        } else if (isTouchEvent(event)) {\n          if (!stateControllers[i]) {\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\n          }\n          if (event.eventType !== EventType.UNDETERMINED) {\n            runWorklet(touchEventTypeToCallbackType(event.eventType), gesture, event, stateControllers[i]);\n          }\n        } else {\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n          if (gesture.onChange && gesture.changeEventCalculator) {\n            var _gesture$changeEventC;\n            runWorklet(CALLBACK_TYPE.CHANGE, gesture, (_gesture$changeEventC = gesture.changeEventCalculator) === null || _gesture$changeEventC === void 0 ? void 0 : _gesture$changeEventC.call(gesture, event, lastUpdateEvent.value[gesture.handlerTag]));\n            lastUpdateEvent.value[gesture.handlerTag] = event;\n          }\n        }\n      }\n    }\n  };\n  var event = Reanimated.useEvent(callback, ['onGestureHandlerStateChange', 'onGestureHandlerEvent'], needsRebuild);\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\nexport var GestureDetector = function GestureDetector(props) {\n  var _gestureConfig$toGest, _gestureConfig$toGest2;\n  var gestureConfig = props.gesture;\n  var gesture = (_gestureConfig$toGest = gestureConfig === null || gestureConfig === void 0 ? void 0 : (_gestureConfig$toGest2 = gestureConfig.toGestureArray) === null || _gestureConfig$toGest2 === void 0 ? void 0 : _gestureConfig$toGest2.call(gestureConfig)) !== null && _gestureConfig$toGest !== void 0 ? _gestureConfig$toGest : [];\n  var useAnimated = gesture.find(function (gesture) {\n    return gesture.handlers.isWorklet.reduce(function (prev, current) {\n      return prev || current;\n    });\n  }) != null;\n  var viewRef = useRef(null);\n  var firstRenderRef = useRef(true);\n  var webEventHandlersRef = useRef({\n    onGestureHandlerEvent: function onGestureHandlerEvent(e) {\n      _onGestureHandlerEvent(e.nativeEvent);\n    }\n  });\n  var preparedGesture = React.useRef({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useAnimated: useAnimated\n  }).current;\n  if (useAnimated !== preparedGesture.useAnimated) {\n    throw new Error('You cannot change whether you are using gesture or animatedGesture while the app is running');\n  }\n  var needsToRebuildReanimatedEvent = preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture);\n  if (preparedGesture.firstExecution) {\n    var _gestureConfig$initia;\n    gestureConfig === null || gestureConfig === void 0 ? void 0 : (_gestureConfig$initia = gestureConfig.initialize) === null || _gestureConfig$initia === void 0 ? void 0 : _gestureConfig$initia.call(gestureConfig);\n  }\n  if (useAnimated) {\n    useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n  }\n  useEffect(function () {\n    firstRenderRef.current = true;\n    var viewTag = findNodeHandle(viewRef.current);\n    attachHandlers({\n      preparedGesture: preparedGesture,\n      gestureConfig: gestureConfig,\n      gesture: gesture,\n      viewTag: viewTag,\n      useAnimated: useAnimated,\n      webEventHandlersRef: webEventHandlersRef\n    });\n    return function () {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n  useEffect(function () {\n    if (!firstRenderRef.current) {\n      var viewTag = findNodeHandle(viewRef.current);\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture: preparedGesture,\n          gestureConfig: gestureConfig,\n          gesture: gesture,\n          viewTag: viewTag,\n          useAnimated: useAnimated,\n          webEventHandlersRef: webEventHandlersRef\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n  if (useAnimated) {\n    return React.createElement(AnimatedWrap, {\n      ref: viewRef,\n      onGestureHandlerEvent: preparedGesture.animatedEventHandler\n    }, props.children);\n  } else {\n    return React.createElement(Wrap, {\n      ref: viewRef\n    }, props.children);\n  }\n};\nvar Wrap = function (_React$Component) {\n  function Wrap() {\n    _classCallCheck(this, Wrap);\n    return _callSuper(this, Wrap, arguments);\n  }\n  _inherits(Wrap, _React$Component);\n  return _createClass(Wrap, [{\n    key: \"render\",\n    value: function render() {\n      var child = React.Children.only(this.props.children);\n      return React.cloneElement(child, {\n        collapsable: false\n      }, child.props.children);\n    }\n  }]);\n}(React.Component);\nvar AnimatedWrap = (_Reanimated$default$c = Reanimated === null || Reanimated === void 0 ? void 0 : (_Reanimated$default = Reanimated.default) === null || _Reanimated$default === void 0 ? void 0 : _Reanimated$default.createAnimatedComponent(Wrap)) !== null && _Reanimated$default$c !== void 0 ? _Reanimated$default$c : Wrap;","map":{"version":3,"names":["React","useEffect","useRef","BaseGesture","CALLBACK_TYPE","Reanimated","registerHandler","unregisterHandler","RNGestureHandlerModule","baseGestureHandlerWithMonitorProps","filterConfig","findNodeHandle","GestureStateManager","flingGestureHandlerProps","forceTouchGestureHandlerProps","longPressGestureHandlerProps","panGestureHandlerProps","panGestureHandlerCustomNativeProps","tapGestureHandlerProps","State","EventType","Platform","onGestureHandlerEvent","ALLOWED_PROPS","concat","_toConsumableArray","convertToHandlerTag","ref","handlerTag","_ref$current$handlerT","_ref$current","current","extractValidHandlerTags","interactionGroup","_interactionGroup$map","_interactionGroup$map2","map","filter","tag","dropHandlers","preparedGesture","handler","config","dropGestureHandler","attachHandlers","_ref","gestureConfig","gesture","viewTag","useAnimated","webEventHandlersRef","firstExecution","initialize","setImmediate","prepare","_loop","createGestureHandler","handlerName","requireToFail","simultaneousWith","updateGestureHandler","simultaneousHandlers","waitFor","OS","attachGestureHandler","animatedHandlers","value","g","handlers","updateHandlers","i","length","needsToReattach","useAnimatedGesture","needsRebuild","isStateChangeEvent","event","oldState","isTouchEvent","eventType","getHandler","type","BEGAN","onBegin","START","onStart","UPDATE","onUpdate","CHANGE","onChange","END","onEnd","FINALIZE","onFinalize","TOUCHES_DOWN","onTouchesDown","TOUCHES_MOVE","onTouchesMove","TOUCHES_UP","onTouchesUp","TOUCHES_CANCELLED","onTouchesCancelled","touchEventTypeToCallbackType","UNDEFINED","runWorklet","isWorklet","_len","arguments","args","Array","_key","apply","console","warn","sharedHandlersCallbacks","useSharedValue","lastUpdateEvent","stateControllers","callback","currentCallback","UNDETERMINED","state","ACTIVE","undefined","FAILED","CANCELLED","create","changeEventCalculator","_gesture$changeEventC","call","useEvent","animatedEventHandler","GestureDetector","props","_gestureConfig$toGest","_gestureConfig$toGest2","toGestureArray","find","reduce","prev","viewRef","firstRenderRef","e","nativeEvent","Error","needsToRebuildReanimatedEvent","_gestureConfig$initia","createElement","AnimatedWrap","children","Wrap","_React$Component","_classCallCheck","_callSuper","_inherits","_createClass","key","render","child","Children","only","cloneElement","collapsable","Component","_Reanimated$default$c","_Reanimated$default","default","createAnimatedComponent"],"sources":["/Users/jensvandevelde/Desktop/MobileApp/node_modules/@ant-design/react-native/node_modules/react-native-gesture-handler/lib/module/handlers/gestures/GestureDetector.tsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport {\n  GestureType,\n  HandlerCallbacks,\n  BaseGesture,\n  GestureRef,\n  CALLBACK_TYPE,\n} from './gesture';\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\nimport {\n  baseGestureHandlerWithMonitorProps,\n  filterConfig,\n  findNodeHandle,\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n  HandlerStateChangeEvent,\n} from '../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from './gestureStateManager';\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\nimport {\n  panGestureHandlerProps,\n  panGestureHandlerCustomNativeProps,\n} from '../PanGestureHandler';\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\nimport { State } from '../../State';\nimport { EventType } from '../../EventType';\nimport { ComposedGesture } from './gestureComposition';\nimport { Platform } from 'react-native';\nimport type RNGestureHandlerModuleWeb from '../../RNGestureHandlerModule.web';\nimport { onGestureHandlerEvent } from './eventReceiver';\n\nconst ALLOWED_PROPS = [\n  ...baseGestureHandlerWithMonitorProps,\n  ...tapGestureHandlerProps,\n  ...panGestureHandlerProps,\n  ...panGestureHandlerCustomNativeProps,\n  ...longPressGestureHandlerProps,\n  ...forceTouchGestureHandlerProps,\n  ...flingGestureHandlerProps,\n];\n\nexport type GestureConfigReference = {\n  config: GestureType[];\n  animatedEventHandler: unknown;\n  animatedHandlers: SharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  > | null;\n  firstExecution: boolean;\n  useAnimated: boolean;\n};\n\nfunction convertToHandlerTag(ref: GestureRef): number {\n  if (typeof ref === 'number') {\n    return ref;\n  } else if (ref instanceof BaseGesture) {\n    return ref.handlerTag;\n  } else {\n    // @ts-ignore in this case it should be a ref either to gesture object or\n    // a gesture handler component, in both cases handlerTag property exists\n    return ref.current?.handlerTag ?? -1;\n  }\n}\n\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\n  return (\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\n  );\n}\n\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\n  for (const handler of preparedGesture.config) {\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\n\n    unregisterHandler(handler.handlerTag);\n  }\n}\n\ninterface WebEventHandler {\n  onGestureHandlerEvent: (event: HandlerStateChangeEvent<unknown>) => void;\n}\n\ninterface AttachHandlersConfig {\n  preparedGesture: GestureConfigReference;\n  gestureConfig: ComposedGesture | GestureType | undefined;\n  gesture: GestureType[];\n  viewTag: number;\n  useAnimated: boolean;\n  webEventHandlersRef: React.RefObject<WebEventHandler>;\n}\n\nfunction attachHandlers({\n  preparedGesture,\n  gestureConfig,\n  gesture,\n  viewTag,\n  useAnimated,\n  webEventHandlersRef,\n}: AttachHandlersConfig) {\n  if (!preparedGesture.firstExecution) {\n    gestureConfig?.initialize();\n  } else {\n    preparedGesture.firstExecution = false;\n  }\n\n  // use setImmediate to extract handlerTags, because all refs should be initialized\n  // when it's ran\n  setImmediate(() => {\n    gestureConfig?.prepare();\n  });\n\n  for (const handler of gesture) {\n    RNGestureHandlerModule.createGestureHandler(\n      handler.handlerName,\n      handler.handlerTag,\n      filterConfig(handler.config, ALLOWED_PROPS)\n    );\n\n    registerHandler(handler.handlerTag, handler);\n\n    // use setImmediate to extract handlerTags, because all refs should be initialized\n    // when it's ran\n    setImmediate(() => {\n      let requireToFail: number[] = [];\n      if (handler.config.requireToFail) {\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\n      }\n\n      let simultaneousWith: number[] = [];\n      if (handler.config.simultaneousWith) {\n        simultaneousWith = extractValidHandlerTags(\n          handler.config.simultaneousWith\n        );\n      }\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n    });\n  }\n  preparedGesture.config = gesture;\n\n  for (const gesture of preparedGesture.config) {\n    if (Platform.OS === 'web') {\n      (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\n        gesture.handlerTag,\n        viewTag,\n        !useAnimated, // send direct events when using animatedGesture, device events otherwise\n        webEventHandlersRef\n      );\n    } else {\n      RNGestureHandlerModule.attachGestureHandler(\n        gesture.handlerTag,\n        viewTag,\n        !useAnimated // send direct events when using animatedGesture, device events otherwise\n      );\n    }\n  }\n\n  if (preparedGesture.animatedHandlers) {\n    preparedGesture.animatedHandlers.value = (gesture.map(\n      (g) => g.handlers\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n  }\n}\n\nfunction updateHandlers(\n  preparedGesture: GestureConfigReference,\n  gestureConfig: ComposedGesture | GestureType | undefined,\n  gesture: GestureType[]\n) {\n  gestureConfig?.prepare();\n\n  for (let i = 0; i < gesture.length; i++) {\n    const handler = preparedGesture.config[i];\n\n    // only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (gesture[i].handlerTag !== handler.handlerTag) {\n      gesture[i].handlerTag = handler.handlerTag;\n      gesture[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  setImmediate(() => {\n    for (let i = 0; i < gesture.length; i++) {\n      const handler = preparedGesture.config[i];\n\n      handler.config = gesture[i].config;\n      handler.handlers = gesture[i].handlers;\n\n      const requireToFail = extractValidHandlerTags(\n        handler.config.requireToFail\n      );\n\n      const simultaneousWith = extractValidHandlerTags(\n        handler.config.simultaneousWith\n      );\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(handler.config, ALLOWED_PROPS, {\n          simultaneousHandlers: simultaneousWith,\n          waitFor: requireToFail,\n        })\n      );\n\n      registerHandler(handler.handlerTag, handler);\n    }\n\n    if (preparedGesture.animatedHandlers) {\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\n        (g) => g.handlers\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\n    }\n  });\n}\n\nfunction needsToReattach(\n  preparedGesture: GestureConfigReference,\n  gesture: GestureType[]\n) {\n  if (gesture.length !== preparedGesture.config.length) {\n    return true;\n  }\n  for (let i = 0; i < gesture.length; i++) {\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction useAnimatedGesture(\n  preparedGesture: GestureConfigReference,\n  needsRebuild: boolean\n) {\n  if (!Reanimated) {\n    return;\n  }\n\n  function isStateChangeEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureStateChangeEvent {\n    'worklet';\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n    return event.oldState != null;\n  }\n\n  function isTouchEvent(\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n  ): event is GestureTouchEvent {\n    'worklet';\n    return event.eventType != null;\n  }\n\n  function getHandler(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>\n  ) {\n    'worklet';\n    switch (type) {\n      case CALLBACK_TYPE.BEGAN:\n        return gesture.onBegin;\n      case CALLBACK_TYPE.START:\n        return gesture.onStart;\n      case CALLBACK_TYPE.UPDATE:\n        return gesture.onUpdate;\n      case CALLBACK_TYPE.CHANGE:\n        return gesture.onChange;\n      case CALLBACK_TYPE.END:\n        return gesture.onEnd;\n      case CALLBACK_TYPE.FINALIZE:\n        return gesture.onFinalize;\n      case CALLBACK_TYPE.TOUCHES_DOWN:\n        return gesture.onTouchesDown;\n      case CALLBACK_TYPE.TOUCHES_MOVE:\n        return gesture.onTouchesMove;\n      case CALLBACK_TYPE.TOUCHES_UP:\n        return gesture.onTouchesUp;\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\n        return gesture.onTouchesCancelled;\n    }\n  }\n\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\n    'worklet';\n    switch (eventType) {\n      case EventType.TOUCHES_DOWN:\n        return CALLBACK_TYPE.TOUCHES_DOWN;\n      case EventType.TOUCHES_MOVE:\n        return CALLBACK_TYPE.TOUCHES_MOVE;\n      case EventType.TOUCHES_UP:\n        return CALLBACK_TYPE.TOUCHES_UP;\n      case EventType.TOUCHES_CANCELLED:\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\n    }\n    return CALLBACK_TYPE.UNDEFINED;\n  }\n\n  function runWorklet(\n    type: CALLBACK_TYPE,\n    gesture: HandlerCallbacks<Record<string, unknown>>,\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n    ...args: any[]\n  ) {\n    'worklet';\n    const handler = getHandler(type, gesture);\n    if (gesture.isWorklet[type]) {\n      // @ts-ignore Logic below makes sure the correct event is send to the\n      // correct handler.\n      handler?.(event, ...args);\n    } else if (handler) {\n      console.warn('Animated gesture callback must be a worklet');\n    }\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag === gesture.handlerTag) {\n        if (isStateChangeEvent(event)) {\n          if (\n            event.oldState === State.UNDETERMINED &&\n            event.state === State.BEGAN\n          ) {\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n          } else if (\n            (event.oldState === State.BEGAN ||\n              event.oldState === State.UNDETERMINED) &&\n            event.state === State.ACTIVE\n          ) {\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\n          } else if (\n            event.oldState !== event.state &&\n            event.state === State.END\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n          } else if (\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\n            event.state !== event.oldState\n          ) {\n            if (event.oldState === State.ACTIVE) {\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n            }\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n          }\n        } else if (isTouchEvent(event)) {\n          if (!stateControllers[i]) {\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\n          }\n\n          if (event.eventType !== EventType.UNDETERMINED) {\n            runWorklet(\n              touchEventTypeToCallbackType(event.eventType),\n              gesture,\n              event,\n              stateControllers[i]\n            );\n          }\n        } else {\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n          if (gesture.onChange && gesture.changeEventCalculator) {\n            runWorklet(\n              CALLBACK_TYPE.CHANGE,\n              gesture,\n              gesture.changeEventCalculator?.(\n                event,\n                lastUpdateEvent.value[gesture.handlerTag]\n              )\n            );\n\n            lastUpdateEvent.value[gesture.handlerTag] = event;\n          }\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    needsRebuild\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n\ninterface GestureDetectorProps {\n  gesture?: ComposedGesture | GestureType;\n}\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\n  props\n) => {\n  const gestureConfig = props.gesture;\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\n  const useAnimated =\n    gesture.find((gesture) =>\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\n    ) != null;\n  const viewRef = useRef(null);\n  const firstRenderRef = useRef(true);\n  const webEventHandlersRef = useRef<WebEventHandler>({\n    onGestureHandlerEvent: (e: HandlerStateChangeEvent<unknown>) => {\n      onGestureHandlerEvent(e.nativeEvent);\n    },\n  });\n\n  const preparedGesture = React.useRef<GestureConfigReference>({\n    config: gesture,\n    animatedEventHandler: null,\n    animatedHandlers: null,\n    firstExecution: true,\n    useAnimated: useAnimated,\n  }).current;\n\n  if (useAnimated !== preparedGesture.useAnimated) {\n    throw new Error(\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\n    );\n  }\n\n  // Reanimated event should be rebuilt only when gestures are reattached, otherwise\n  // config update will be enough as all necessary items are stored in shared values anyway\n  const needsToRebuildReanimatedEvent =\n    preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture);\n\n  if (preparedGesture.firstExecution) {\n    gestureConfig?.initialize?.();\n  }\n\n  if (useAnimated) {\n    // Whether animatedGesture or gesture is used shouldn't change\n    // during while an app is running\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\n  }\n\n  useEffect(() => {\n    firstRenderRef.current = true;\n    const viewTag = findNodeHandle(viewRef.current) as number;\n    attachHandlers({\n      preparedGesture,\n      gestureConfig,\n      gesture,\n      viewTag,\n      useAnimated,\n      webEventHandlersRef,\n    });\n\n    return () => {\n      dropHandlers(preparedGesture);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!firstRenderRef.current) {\n      const viewTag = findNodeHandle(viewRef.current) as number;\n\n      if (needsToReattach(preparedGesture, gesture)) {\n        dropHandlers(preparedGesture);\n        attachHandlers({\n          preparedGesture,\n          gestureConfig,\n          gesture,\n          viewTag,\n          useAnimated,\n          webEventHandlersRef,\n        });\n      } else {\n        updateHandlers(preparedGesture, gestureConfig, gesture);\n      }\n    } else {\n      firstRenderRef.current = false;\n    }\n  }, [props]);\n\n  if (useAnimated) {\n    return (\n      <AnimatedWrap\n        ref={viewRef}\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\n        {props.children}\n      </AnimatedWrap>\n    );\n  } else {\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\n  }\n};\n\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\n  render() {\n    // I don't think that fighting with types over such a simple function is worth it\n    // The only thing it does is add 'collapsable: false' to the child component\n    // to make sure it is in the native view hierarchy so the detector can find\n    // correct viewTag to attach to.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const child: any = React.Children.only(this.props.children);\n\n    return React.cloneElement(\n      child,\n      { collapsable: false },\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      child.props.children\n    );\n  }\n}\n\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}